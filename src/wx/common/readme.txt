


统一账号密码长度：

账号：最长16位，最小位数：4，

密码：最长32位，最小6位

昵称：最大：16位。群名称

签名：最大18.


此文件夹，是公用的。cat和rat一样。


entity类不依赖任何东西，可以多。放一起。


// 服务器有信息时，往app推送。   app要主动改变某信息时才用http请求。     在线app必须保持长连接，否则认为网络连接有问题。

// app中，获取结果，如个人设置获取，必须使用http
// 发送类，先尝试长连接，如果发送失败再尝试http，如果还是失败，返回失败。
// Android中，当我发送信息后，和，我接收到信息后，打开长连接，直到自己断开或者(30分钟？)
// 没有长连接的时候，http轮询，6分钟一次。
// 既然决定使用http轮询，那么，ws仅仅作为是否有信息通知(0,1即可)。有新消息后，httpApp发送请求(附带已经接受到的标识)，pc返回新消息，直到没有消息返回为止
// 发送消息也全部使用http


tcp长链接：
一个服务器间，建立一个长链接，足以传送大规模数据。   通常，jvm和CPU先扛不住。tcp不是瓶颈。

netty间的websocket，和，OKhttp间的websocket，在发送消息时都会返回是否成功标识，OKhttp阻塞，netty客户端非阻塞。当jvm溢出，会有消息泄露现象。


//////////////    聊天，应该尝试可以，直接连接好友服务器，发送聊天信息。仅仅需要考虑安全问题即可。

/*

ExecutorService executorService = Executors.newFixedThreadPool(3);
线程数目和有多少task进入队列没有关系。即使线程个数已满，task还是会进入队里中。关于超时问题，future.get()应该是会报超时错误的。

       1 executorService.execute(new Runnable() 和 2 executorService.submit(new Callable<String>()

        1，不抛异常。不返回结果，不阻塞。

        2,当不适用future.get()获取结果时和1一样。。。当使用future.get()时：阻塞、返结果、有异常抛出报错

*/



方法：_http结尾只能使用http请求(特征：只能是app请求、ser间全是ws)。。。
_ws只能用长连接。。。两个结尾都没有的可以用用于所有类型请求（所有类型请求特征是没有返回信息。）
谁知道，有没有不允许长连接的情况，所以，全部都可以改成http吧，业务逻辑不要依赖ws




